snippet @p
@property
def $1(self):
	$0

@$1.setter
def $1(self, value)
	self._$1 = value
endsnippet

snippet lc "list comprension"
${1:var} = [${2:o} for $2 in ${3:iterable}]
endsnippet

snippet dc "dictionary comprension"
${1:var} = {${2:k}: ${3:v} for $2, $3 in ${4:iterable}}
endsnippet

snippet lj "json load" b
with open(${1:filename}) as file:
	${2:data} = json.load(file)
	$0
endsnippet

snippet wof
with open($1) as file:
	${2:data} = [line.strip() for line in file]
	$0
endsnippet

snippet cl "basic class" -b
class $1:
	"""${2:<++>}"""

	def __init__(self$3):
		$0
endsnippet

snippet p "print"
print("$0")
endsnippet

snippet pf "print with fstring"
print(f"$0")
endsnippet

snippet d "basic function" -b
def $1($2):
	"""${3:<++>}"""
	$0
endsnippet

snippet dm "def main"
def main($1):
    $0
endsnippet

snippet li "log info" b
log.info("$0")
endsnippet

snippet ifm "setup main" -b
def main():
	$0


if __name__ == "__main__":
	main()
endsnippet

snippet pld "disable pylint"
# pylint: disable=$1
endsnippet

snippet bp "basepath stuff"
basepath = pathlib.Path(__file__).resolve().parent
endsnippet

snippet spa "basepath stuff" b
basepath = pathlib.Path(__file__).resolve().parent
sys.path.append(str(basepath))
endsnippet

snippet sup "default super"
super().__init__()
endsnippet

snippet ipl "pathlib"
import pathlib
endsnippet

snippet #h "header"
#!/usr/bin/env python
# coding: utf-8
# Author: James Casey <hanavi@gmail.com>
# Last Updated: __DATE__
endsnippet

snippet df "fancy function" b
def $1($2) -> ${3:None}:
    """$4

    Parameters
    ---------- `!p
args = t[2].split(",")
snip.rv = ''
for arg in args:
    arg = arg.strip()
    arg = arg.split(":")[0]
    snip += f"        {arg}: <++>"
snip.rv += "\n" + snip.mkline(line='', indent=None)
`
    Returns
    -------
	    ${5:None}
    """

endsnippet

snippet dsp "Doc strings"
Parameters
----------
	$1

Returns
-------
	$2
endsnippet

snippet se "self objects"
self.$1 = $1
endsnippet

snippet s "self objects"
self.$1
endsnippet

snippet " "docstring"
"""$1"""
endsnippet

snippet @cl "click" b
@click.command()
@click.option("-${1:v}", "--${2:verbose}", is_flag=${3:True}, default=${4:False},
    help="${5:Verbose output}")
endsnippet

snippet @co "click" b
@click.option("-$1", "--$2", is_flag=${3:False}, default=${4:None},
    help="$5")
endsnippet

snippet jp "Prety print json" b
print(json.dumps($1, indent=4))
endsnippet

snippet pv "Print Variable"
print(f"{${1:variable}=}")
endsnippet

snippet @r "New @route"
@app.route("/$1")
def ${2:function}($3):
    pass
endsnippet

snippet dfv "create a dictionary from variables (copy keyname to var)" b
$1 = {
    $2
`!p

entries = t[2]

snip.rv = ''
if entries:
    ovars = entries.split(",")
    for line in ovars:
        snip += '    "{}": {},'.format(line, line)
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet si "quick and dirty self initializer" b
self.$1 = $1
endsnippet


snippet dfv2 "create a dictionary from variables (<++> for vars)" b
$1 = {
    $2
`!p

entries = t[2]

snip.rv = ''
if entries:
    ovars = entries.split(",")
    for line in ovars:
        snip += '    "{}": <++>,'.format(line)
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfs "create a dictionary with strings for var" b
$1 = {
    $2
`!p

entries = t[2]

snip.rv = ''
if entries:
    ovars = entries.split(",")
    for line in ovars:
        snip += '    "{}": "<++>",'.format(line)
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfl "Generate a dict from a list" b
$1 = {
    $2
`!p
entries = t[2].split(' ')
entvar = entries[0]

snip.rv = ''
if len(entries) > 1:
    ovars = entries[1].split(",")
    for i, line in enumerate(ovars):
        snip += '    "{}": {}[{}],'.format(line, entvar, i)
    snip.rv += '\n' + snip.mkline(line='',indent=None)
`}
endsnippet

snippet dfd "Generate a dict from a dict" b
$1 = {
    $2
`!p
entries = t[2].split(' ')
entvar = entries[0]

snip.rv = ''
if len(entries) > 1:
    ovars = entries[1].split(",")
    for i, line in enumerate(ovars):
        snip += '    "{}": {}["<++>"],'.format(line, entvar, i)
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfva "create a dictionary from vars with alignment (copy keyname to var)" b
$1 = {
    $2
`!p

entries = t[2]

snip.rv = ''
if entries:
    ovars = entries.split(",")
    ml = max([len(x) for x in ovars])
    for line in ovars:
        snip += '    "{}":'.format(line) + " "*(ml-len(line)) + ' {},'.format(line)
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfva2 "create a dictionary with alignment (<++> for vars)" b
$1 = {
    $2
`!p

entries = t[2]

snip.rv = ''
if entries:
    ovars = entries.split(",")
    ml = max([len(x) for x in ovars])
    for line in ovars:
        snip += '    "{}":'.format(line) + " "*(ml-len(line)) + ' <++>,'
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfsa "dictionary from strings with alignment" b
$1 = {
    $2
`!p

entries = t[2]

snip.rv = ''
if entries:
    ovars = entries.split(",")
    ml = max([len(x) for x in ovars])
    for line in ovars:
        snip += '    "{}":'.format(line) + " "*(ml-len(line)) + ' "<++>",'
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfda "Dict from dict align" b
$1 = {
    $2
`!p
entries = t[2].split(' ')
entvar = entries[0]

snip.rv = ''
if len(entries) > 1:
    ovars = entries[1].split(",")
    ml = max([len(x) for x in ovars])
    for i, line in enumerate(ovars):
        snip += '    "{}":'.format(line) + " "*(ml-len(line))+ ' {}["<++>"],'.format(entvar)
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfla "Dict from list align" b
$1 = {
    $2
`!p
entries = t[2].split(' ')
entvar = entries[0]

snip.rv = ''
if len(entries) > 1:
    ovars = entries[1].split(",")
    ml = max([len(x) for x in ovars])
    for i, line in enumerate(ovars):
        snip += '    "{}":'.format(line) + " "*(ml-len(line))+ ' {}[{}],'.format(entvar, i)
    snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet vfd "variables from dict aligned" b
$1
`!p
entries = t[1].split(' ')
dictvar = entries[0]

snip.rv = ''
if len(entries) > 1:
    ovars = entries[1].split(",")
    for line in ovars:
        snip +=  '{} ='.format(line) + ' {}["{}"]'.format(dictvar, line)
`
endsnippet

snippet vfda "variables from dict aligned" b
$1
`!p
entries = t[1].split(' ')
dictvar = entries[0]

snip.rv = ''
if len(entries) > 1:
    ovars = entries[1].split(",")
    ml = max([len(x) for x in ovars])
    for line in ovars:
        snip += '{} '.format(line) + " "*(ml-len(line)) + '= {}["{}"]'.format(dictvar, line)
`
endsnippet

snippet vfd2 "variables from dict" b
$1
`!p
entries = t[1].split(' ')
dictvar = entries[0]

snip.rv = ''
if len(entries) > 1:
    ovars = entries[1].split(",")
    for line in ovars:
        snip += '{} ='.format(line) + ' {}["<++>"]'.format(dictvar)
`
endsnippet

snippet tn "torch.nn" b
from torch import nn
endsnippet

snippet fn "filename"
${1:filename} = pathlib.Path(${2:__file__}).resolve().parent
endsnippet

# snippet dg
# log.debug(f'$1: {$1}')
# endsnippet

# snippet ig
# log.info(f'$1: {$1}')
# endsnippet
