snippet @p
@property
def $1(self):
	$0

@$1.setter
def $1(self, value)
	self._$1 = value
endsnippet

snippet jp "Prety print json" b
print(json.dumps($1, indent=4))
endsnippet

snippet lc "list comprension"
${1:var}: list[$2] = [${3:o} for ${4:o} in ${5:iterable}]
endsnippet

snippet dc "dictionary comprension"
${1:var} = {${2:k}: ${3:v} for $2, $3 in ${4:iterable}}
endsnippet

snippet lj "json load" b
with open(${1:filename}) as file:
	${2:data} = json.load(file)
	$0
endsnippet

snippet wof
with open($1) as file:
	${2:data} = [line.strip() for line in file]
	$0
endsnippet

snippet cl "basic class" -b
class $1:
	"""${2:<++>}"""

	def __init__(self$3) -> None:
		super().__init__()
		$0
endsnippet

snippet p "print"
print("$0")
endsnippet

snippet fp "print with fstring"
print(f"$0")
endsnippet

snippet d "basic function" -b
def $1($2):
	"""${3:<++>}"""
	$0
endsnippet

snippet dm "def main"
def main($1):
	$0
endsnippet

snippet li "log info" b
log.info("$0")
endsnippet

snippet ld "log debug" b
log.debug(f'$1: {$1}')
endsnippet

snippet ifm "setup main" -b
def main():
	$0


if __name__ == "__main__":
	main()
endsnippet

snippet pld "disable pylint"
# pylint: disable=$1
endsnippet

snippet bp "basepath stuff"
basepath = Path(__file__).resolve().parent
endsnippet

snippet spa "basepath stuff" b
basepath = Path(__file__).resolve().parent
sys.path.append(str(basepath))
endsnippet

snippet di "default init" b
def __init__(self) -> None:
	super().__init__()
	$1
endsnippet

snippet sup "default super" b
super().__init__()
endsnippet

snippet ipl "pathlib" b
from pathlib import Path
endsnippet

snippet mpl "matplotlib" b
from matplotlib import pyplot as plt
endsnippet

snippet fdc "dataclasses"
from dataclasses import dataclass
endsnippet

snippet #h "header" b
#!/usr/bin/env python
# Author: James Casey <hanavi@gmail.com>
# Last Updated: __DATE__
endsnippet

snippet i "import" b
import $1
endsnippet

snippet fi "import" b
from $1 import $2
endsnippet
snippet df "fancy function" b
def $1($2) -> ${3:None}:
	"""$4

	Parameters
	---------- `!p
args = t[2].split(",")
snip.rv = ''
for arg in args:
	arg = arg.strip()
	arg = arg.split(":")[0]
	snip += f"        {arg}: <++>"
snip.rv += "\n" + snip.mkline(line='', indent=None)
`
	Returns
	-------
		${5:None}
	"""

endsnippet

snippet dsp "Doc strings"
Parameters
----------
	$1

Returns
-------
	$2
endsnippet

snippet se "self objects"
self.$1 = $1
endsnippet

snippet s "self objects"
self.$1
endsnippet

snippet " "docstring"
"""$1"""
endsnippet

snippet @cl "click" b
@click.command()
@click.option("-${1:v}", "--${2:verbose}", is_flag=${3:True}, default=${4:False},
	help="${5:Verbose output}")
endsnippet

snippet @co "click" b
@click.option("-$1", "--$2", is_flag=${3:False}, default=${4:None},
	help="$5")
endsnippet


snippet pv "Print Variable"
print(f"{${1:variable}=}")
endsnippet

snippet @r "New @route"
@app.route("/$1")
def ${2:function}($3):
	pass
endsnippet

snippet dfv "create a dictionary from variables (copy keyname to var)" b
$1 = {
	$2
`!p

entries = t[2]

snip.rv = ''
if entries:
	ovars = entries.split(",")
	for line in ovars:
		snip += '    "{}": {},'.format(line, line)
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet sv "quick and dirty self initializer" b
self.$1 = $1
endsnippet


snippet dfv2 "create a dictionary from variables (<++> for vars)" b
$1 = {
	$2
`!p

entries = t[2]

snip.rv = ''
if entries:
	ovars = entries.split(",")
	for line in ovars:
		snip += '    "{}": <++>,'.format(line)
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfs "create a dictionary with strings for var" b
$1 = {
	$2
`!p

entries = t[2]

snip.rv = ''
if entries:
	ovars = entries.split(",")
	for line in ovars:
		snip += '    "{}": "<++>",'.format(line)
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfl "Generate a dict from a list" b
$1 = {
	$2
`!p
entries = t[2].split(' ')
entvar = entries[0]

snip.rv = ''
if len(entries) > 1:
	ovars = entries[1].split(",")
	for i, line in enumerate(ovars):
		snip += '    "{}": {}[{}],'.format(line, entvar, i)
	snip.rv += '\n' + snip.mkline(line='',indent=None)
`}
endsnippet

snippet dfd "Generate a dict from a dict" b
$1 = {
	$2
`!p
entries = t[2].split(' ')
entvar = entries[0]

snip.rv = ''
if len(entries) > 1:
	ovars = entries[1].split(",")
	for i, line in enumerate(ovars):
		snip += '    "{}": {}["<++>"],'.format(line, entvar, i)
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfva "create a dictionary from vars with alignment (copy keyname to var)" b
$1 = {
	$2
`!p

entries = t[2]

snip.rv = ''
if entries:
	ovars = entries.split(",")
	ml = max([len(x) for x in ovars])
	for line in ovars:
		snip += '    "{}":'.format(line) + " "*(ml-len(line)) + ' {},'.format(line)
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfva2 "create a dictionary with alignment (<++> for vars)" b
$1 = {
	$2
`!p

entries = t[2]

snip.rv = ''
if entries:
	ovars = entries.split(",")
	ml = max([len(x) for x in ovars])
	for line in ovars:
		snip += '    "{}":'.format(line) + " "*(ml-len(line)) + ' <++>,'
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfsa "dictionary from strings with alignment" b
$1 = {
	$2
`!p

entries = t[2]

snip.rv = ''
if entries:
	ovars = entries.split(",")
	ml = max([len(x) for x in ovars])
	for line in ovars:
		snip += '    "{}":'.format(line) + " "*(ml-len(line)) + ' "<++>",'
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfda "Dict from dict align" b
$1 = {
	$2
`!p
entries = t[2].split(' ')
entvar = entries[0]

snip.rv = ''
if len(entries) > 1:
	ovars = entries[1].split(",")
	ml = max([len(x) for x in ovars])
	for i, line in enumerate(ovars):
		snip += '    "{}":'.format(line) + " "*(ml-len(line))+ ' {}["<++>"],'.format(entvar)
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet dfla "Dict from list align" b
$1 = {
	$2
`!p
entries = t[2].split(' ')
entvar = entries[0]

snip.rv = ''
if len(entries) > 1:
	ovars = entries[1].split(",")
	ml = max([len(x) for x in ovars])
	for i, line in enumerate(ovars):
		snip += '    "{}":'.format(line) + " "*(ml-len(line))+ ' {}[{}],'.format(entvar, i)
	snip.rv += "\n" + snip.mkline(line='', indent=None)
`}
endsnippet

snippet vfd "variables from dict aligned" b
$1
`!p
entries = t[1].split(' ')
dictvar = entries[0]

snip.rv = ''
if len(entries) > 1:
	ovars = entries[1].split(",")
	for line in ovars:
		snip +=  '{} ='.format(line) + ' {}["{}"]'.format(dictvar, line)
`
endsnippet

snippet vfda "variables from dict aligned" b
$1
`!p
entries = t[1].split(' ')
dictvar = entries[0]

snip.rv = ''
if len(entries) > 1:
	ovars = entries[1].split(",")
	ml = max([len(x) for x in ovars])
	for line in ovars:
		snip += '{} '.format(line) + " "*(ml-len(line)) + '= {}["{}"]'.format(dictvar, line)
`
endsnippet

snippet vfd2 "variables from dict" b
$1
`!p
entries = t[1].split(' ')
dictvar = entries[0]

snip.rv = ''
if len(entries) > 1:
	ovars = entries[1].split(",")
	for line in ovars:
		snip += '{} ='.format(line) + ' {}["<++>"]'.format(dictvar)
`
endsnippet

snippet ip "pandas" b
import pandas as pd
endsnippet

snippet it "torch" b
import torch
endsnippet

snippet tr "torch"
torch.rand($0)
endsnippet

snippet tri "torch"
torch.randint($0)
endsnippet

snippet nn "torch.nn" b
from torch import nn
endsnippet

snippet tf "torch functional" b
from torch.nn import functional as F
endsnippet

snippet tt "torchvision transforms" b
from torchvision import transforms as T
endsnippet

snippet fn "filename"
${1:filename} = Path(${2:__file__}).resolve().parent
endsnippet

snippet home "filename"
${1:filename} = Path.home()
endsnippet

snippet tl "lightning module headers" b
from torch import optim
from torch.nn import functional as F
from torchmetrics.functional import accuracy
import lightning as L
endsnippet

snippet lm "lightning module" b
class LitModel(L.LightningModule):
	"""Basic lightning model."""

	def __init__(self, model, learning_rate=None):
		super().__init__()

		self.model = model
		self.learning_rate = learning_rate if learning_rate is not None else 1e-4

	def configure_optimizers(self):
		"""Configure optimizer."""

		optimizer = optim.AdamW(self.model.parameters(), lr=self.learning_rate)
		return optimizer

	def training_step(self, batch):
		"""Training step."""

		data, labels = batch
		preds = self.model(data)
		loss = F.cross_entropy(preds, labels)
		self.log('loss/training', loss)

		return loss

	def validation_step(self, batch):
		"""Validation step."""

		data, labels = batch
		preds = self.model(data)
		loss = F.cross_entropy(preds, labels)
		val_accuracy = accuracy(preds, target, task='binary')

		self.log('loss/validation', loss)
		self.log('accuracy', val_accuracy)

		return loss
endsnippet

snippet lt "lightning trainer" b
train_loader, valid_loader = load_data()

model  = load_model()
lit_model = LitModel(model)

trainer = L.Trainer()
trainer.fit(
	lit_model,
	train_dataloaders=train_loader,
	val_dataloaders=valid_loader,
	max_epochs=100,
)
endsnippet

snippet fc "foo class" b
class

endsnippet
